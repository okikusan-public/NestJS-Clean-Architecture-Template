# NestJS Clean Architecture Template

This repository provides a template for building applications using NestJS and Clean Architecture principles. It promotes a scalable and maintainable structure for your NestJS projects.


## Overview

The NestJS Clean Architecture Template is designed to help developers create robust and maintainable applications by following the principles of Clean Architecture. It separates the application into distinct layers, ensuring a clear separation of concerns and promoting modularity.

## Folder Structure

The template organizes the application code under the `src` directory using the following folder structure:

```
├── src
│   ├── application
│   │   └── sample
│   ├── domains
│   │   └── sample
│   │       ├── entities
│   │       ├── repositories
│   │       └── services
│   ├── infrastructure
│   │   ├── postgres
│   ├── migrations
│   └── interfaces
│       └── web
└── test
```

- `application`: This folder contains the application layer of the Clean Architecture. It includes use cases and application-specific logic. In the example, there is a `sample` folder representing a sample application.

- `domains`: This folder represents the domain layer of the Clean Architecture. It contains the core business logic, entities, repositories, and services. The `sample` folder is an example of a domain within the application.
  - `entities`: This folder contains the domain entities, which represent the core business objects and their behavior.
  - `repositories`: This folder contains the repository interfaces. Repositories provide an abstraction layer between the domain and the data persistence layer, defining the contract for interacting with the database or other data sources.
  - `services`: This folder contains the domain services, which encapsulate the business logic and operations related to the domain.

- `infrastructure`: This folder represents the infrastructure layer of the Clean Architecture. It includes the implementation details of external services, databases, and other infrastructure-related components. The repository implementations, which depend on specific technologies like databases or ORMs, are also placed in this layer.

- `interfaces`: This folder contains the interface layer of the Clean Architecture. It includes the user interface, APIs, and other entry points to the application.
  - `web`: This folder represents the web interface of the application, which can include controllers, resolvers, and other web-related components.

- `migrations`: This folder contains the migration files generated by TypeORM. Migrations are used to manage and version the database schema changes. They ensure that the database schema is consistent with the application's current state and can be easily updated or rolled back as needed.

- `test`: This folder contains the unit tests and integration tests for the application.

The folder structure follows the principles of Clean Architecture, where each layer has a specific responsibility and depends only on the layers below it. This promotes a clear separation of concerns and makes the application more modular and maintainable.

## Prerequisites

Before getting started with the template, ensure that you have the following installed on your local machine:

- **Node.js 22.20.0**: Use `nvm use` if you have Node Version Manager installed.
- Docker: The template uses Docker to set up the development environment and run the application.

## Building the Application

To build the application, follow these steps:

1. Clone the repository to your local machine.
2. Open a terminal and navigate to the project's root directory.
3. Run the following command to build the Docker containers:

   ```
   docker compose build
   ```

   This command will build the NestJS application using the provided Dockerfile.

## Running the Application

Once the application is built, you can run it using Docker Compose:

1. In the terminal, make sure you are in the project's root directory.
2. Run the following command to start the application:

   ```
   docker compose up
   ```

   This command will start the NestJS application and its associated services defined in the `docker-compose.yml` file.

   During the startup process, the application will also run any pending migrations to ensure that the database schema is up to date.

3. Access the application by opening a web browser and navigating to `http://localhost:3000`.

### Running the Application Locally (without Docker)

If you would rather run the API directly on your machine, follow these steps:

1. Create a `.env` file by copying `.env_sample` and updating the database credentials to point to a running PostgreSQL instance. You can reuse the containerized database by running only that service: `docker compose up postgres`.

2. Install the project dependencies:

   ```
   npm install
   ```

3. Apply the latest database migrations so the schema matches the entities:

   ```
   npm run migration:run
   ```

4. Start the development server:

   ```
   npm run start:dev
   ```

   This command launches the NestJS application with hot-reload enabled. The API becomes available at `http://localhost:3000`.

5. Stop the development server with `Ctrl+C` when you are done.

### Running Tests

Execute the project's automated tests with the following commands:

- Unit tests:

  ```
  npm run test
  ```

- End-to-end tests:

  ```
  npm run test:e2e
  ```

The Jest runner automatically sets `NODE_ENV=test`, which instructs the application to spin up an ephemeral in-memory SQLite database. As a result, you no longer need a PostgreSQL instance to execute the end-to-end test suite.

> **Note:** The SQLite driver is installed as a development dependency. Make sure you run `npm install` (without omitting dev dependencies) before executing the E2E suite so that the native bindings are available.

## Dockerfile

The provided Dockerfile defines the steps to build the NestJS application container. It starts with a Node.js 22.20.0 (LTS) Alpine base image, copies the application files, installs the dependencies, builds the application, and sets the command to run the application using the `node` command.

## Docker Compose

The `docker-compose.yml` file defines the services required for running the NestJS application. It includes two services:

1. `nestjs`: The NestJS application service, which is built using the provided Dockerfile. It maps port 3000 from the container to the host machine, mounts the application directory as a volume, and sets the command to run the application in development mode using `npm run start:dev`. The service also loads environment variables from the `.env` file.

2. `postgres`: The PostgreSQL database service, which uses the official PostgreSQL 16.2 image. It maps port 5432 from the container to the host machine, mounts a named volume for data persistence, and loads environment variables from the `.env` file.

The `volumes` section defines a named volume `postgres-data` to persist the PostgreSQL data across container restarts.

## Generating a New Migration File

To generate a new migration, ensure the NestJS Docker container is running, then execute the following command. Note that a new migration will only be created if there are differences in the entities:
```
docker exec -it <nestjs container_id> npx typeorm-ts-node-commonjs migration:generate ./src/migrations/<migration filename> -d data-source.ts
```

## Environment Variables

The application requires the following environment variables to be set. You can use the `.env_sample` file as a reference to create your own `.env` file.

### Database Configuration (Master-Slave Replication)

- `DB_MASTER_HOST`: The hostname of the master database server.
- `DB_MASTER_PORT`: The port number on which the master database server is listening.
- `DB_MASTER_USER`: The username for the master database connection.
- `DB_MASTER_PASSWORD`: The password for the master database connection.
- `DB_MASTER_NAME`: The name of the master database.
- `DB_SLAVE_HOST`: The hostname of the slave database server (can be the same as master for local development).
- `DB_SLAVE_PORT`: The port number on which the slave database server is listening.
- `DB_SLAVE_USER`: The username for the slave database connection.
- `DB_SLAVE_PASSWORD`: The password for the slave database connection.
- `DB_SLAVE_NAME`: The name of the slave database.
- `DB_SYNCRONIZE`: A boolean value to synchronize the database schema (use `false` in production).

### Local Environment Variables (Docker)

The following variables are used only in the local environment when using Docker to run PostgreSQL:

- `POSTGRES_USER`: The PostgreSQL user.
- `POSTGRES_PASSWORD`: The PostgreSQL password.
- `POSTGRES_DB`: The PostgreSQL database name.

Ensure that you have a `.env` file in the root directory of your project with the appropriate values for these variables.


## Conclusion

The NestJS Clean Architecture Template provides a solid foundation for building scalable and maintainable applications using NestJS and Clean Architecture principles. By following the provided build and run instructions, you can quickly set up and start developing your application with a clean and organized structure.

Feel free to explore the template, customize it to your needs, and happy coding!

